[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "modal-examples",
    "section": "",
    "text": "Preface\nThis is a Quarto book on notes on running Modal examples.\nThis is meant as a personal reference and not an official guide on Modal.\nAll credit should be given to the Modal team for a wonderful tool and example setup."
  },
  {
    "objectID": "01_getting_started.html",
    "href": "01_getting_started.html",
    "title": "1Â  Getting Started",
    "section": "",
    "text": "2 hello_world.py\nNow weâ€™ll start with this file:\nNow letâ€™s look at the next file:\nWe can also glance at how generators vary for remote vs local with:\nThen if we run:"
  },
  {
    "objectID": "01_getting_started.html#clone-repo",
    "href": "01_getting_started.html#clone-repo",
    "title": "1Â  Getting Started",
    "section": "1.1 Clone repo",
    "text": "1.1 Clone repo\ngit clone https://github.com/modal-labs/modal-examples.git"
  },
  {
    "objectID": "01_getting_started.html#modal-setup",
    "href": "01_getting_started.html#modal-setup",
    "title": "1Â  Getting Started",
    "section": "1.2 Modal setup",
    "text": "1.2 Modal setup\n$ modal setup\n\nThe web browser should have opened for you to authenticate and get an API token.\nIf it didn't, please copy this URL into your web browser manually:\n\nhttps://modal.com/token-flow/tf-xxxxxxxxxxx\n\nWeb authentication finished successfully!\nToken is connected to the charlotte-llm workspace.\nVerifying token against https://api.modal.com\nToken verified successfully!\nToken written to /Users/ryan/.modal.toml in profile charlotte-llm."
  },
  {
    "objectID": "01_getting_started.html#running-our-function-locally-remotely-and-in-parallel",
    "href": "01_getting_started.html#running-our-function-locally-remotely-and-in-parallel",
    "title": "1Â  Getting Started",
    "section": "2.1 Running our function locally, remotely, and in parallel",
    "text": "2.1 Running our function locally, remotely, and in parallel\nThree different ways we can call that function:\n\nAs a regular local call on your computer, with f.local\nAs a remote call that runs in the cloud, with f.remote\nBy mapping many copies of f in the cloud over many inputs, with f.map\n\n$ cd 01_getting_started\n$ modal run hello_world.py\nâœ“ Initialized. View run at https://modal.com/charlotte-llm/main/apps/ap-xxxxxxxxx\nâœ“ Created objects.\nâ”œâ”€â”€ ğŸ”¨ Created mount /modal-examples/01_getting_started/hello_world.py\nâ””â”€â”€ ğŸ”¨ Created function f.\nhello 1000\n1000000\n1000000\nhello 1000\nhello 0\nworld 1\nhello 2\nworld 3\nhello 4\nworld 5\nhello 6\nworld 7\nhello 8\nworld 9\nhello 10\nworld 11\nhello 12\nworld 13\nhello 14\nworld 15\nhello 16\nworld 17\nhello 18\nworld 19\n2470\nStopping app - local entrypoint completed.\nâœ“ App completed. View run at https://modal.com/charlotte-llm/main/apps/ap-xxxxxxxxx\n\n2.1.1 What just happened?\nWhen we called .remote on f, the function was executed in the cloud, on Modalâ€™s infrastructure, not locally on our computer.\nIn short, we took the function f, put it inside a container, sent it the inputs, and streamed back the logs and outputs.\n\n\n2.1.2 But why does this matter?\nTry doing one of these things next to start seeing the full power of Modal!\n\n\n2.1.3 Change the code\nIâ€™ll change the print to â€œspamâ€ and â€œeggsâ€:\n\n\nhello_world_spam.py\n\nimport sys\nimport modal\n\napp = modal.App(\"example-hello-world\")\n\n@app.function()\ndef f(i):\n    if i % 2 == 0:\n        print(\"spam\", i)\n    else:\n        print(\"eggs\", i, file=sys.stderr)\n\n    return i * i\n\n@app.local_entrypoint()\ndef main():\n    # run the function locally\n    print(f.local(1000))\n\n    # run the function remotely on Modal\n    print(f.remote(1000))\n\n    # run the function in parallel and remotely on Modal\n    total = 0\n    for ret in f.map(range(20)):\n        total += ret\n\n    print(total)\n\nThen run:\n$ modal run hello_world_spam.py\nâœ“ Initialized. View run at https://modal.com/charlotte-llm/main/apps/ap-xxxxxxxxx\nâœ“ Created objects.\nâ”œâ”€â”€ ğŸ”¨ Created mount /modal-examples/01_getting_started/hello_world_spam.py\nâ””â”€â”€ ğŸ”¨ Created function f.\nspam 1000\n1000000\nspam 1000\n1000000\nspam 0\neggs 1\nspam 2\neggs 3\nspam 4\neggs 5\nspam 6\neggs 7\nspam 8\neggs 9\nspam 10\neggs 11\nspam 12\neggs 13\nspam 14\neggs 15\nspam 16\neggs 17\nspam 18\neggs 19\n2470\nStopping app - local entrypoint completed.\nâœ“ App completed. View run at https://modal.com/charlotte-llm/main/apps/ap-xxxxxxxxx\nI can view the output via browser:\n\nThis example is obviously very simple, but there are many other things you can do with modal like:\n\nRunning language model inference or fine-tuning\nManipulating audio or images\nCollecting financial data to backtest a trading algorithm."
  },
  {
    "objectID": "01_getting_started.html#decorators",
    "href": "01_getting_started.html#decorators",
    "title": "1Â  Getting Started",
    "section": "3.1 Decorators",
    "text": "3.1 Decorators\nNotice the two different app decorators: @app.function() and @app.local_entrypoint().\n\n\n\n\n\n\nFrom the docs, a local_entrypoint:\n\n\n\n&gt; def local_entrypoint(\n    self, _warn_parentheses_missing=None, *, name: Optional[str] = None\n) -&gt; Callable[[Callable[..., Any]], None]:\nDecorate a function to be used as a CLI entrypoint for a Modal App.\nThese functions can be used to define code that runs locally to set up the app, and act as an entrypoint to start Modal functions from. Note that regular Modal functions can also be used as CLI entrypoints, but unlike local_entrypoint, those functions are executed remotely directly.\n@app.local_entrypoint()\ndef main():\n    some_modal_function.remote()\nYou can call the function using modal run directly from the CLI:\nmodal run app_module.py\nNote that an explicit app.run() is not needed, as an app is automatically created for you.\n\n\nWe can run:\n$ modal run get_started.py     \nâœ“ Initialized. View run at https://modal.com/charlotte-llm/main/apps/ap-xxxxxxxxx\nâœ“ Created objects.\nâ”œâ”€â”€ ğŸ”¨ Created mount /modal-examples/01_getting_started/get_started.py\nâ””â”€â”€ ğŸ”¨ Created function square.\nthe square is 1764\nThis code is running on a remote worker!\nStopping app - local entrypoint completed.\nâœ“ App completed. View run at https://modal.com/charlotte-llm/main/apps/ap-xxxxxxxxx\nNow I wonder what happens if I create a similar new file:\n\n\nget_started_local.py\n\nimport modal\n\napp = modal.App(\"example-get-started-local\")\n\n\n@app.function()\ndef square(x):\n    print(\"This code is running on a local worker!\")\n    return x**2\n\n\n@app.local_entrypoint()\ndef main():\n    print(\"the square is\", square.local(42))\n\nAnd then run:\n$ modal run get_started_local.py\nâœ“ Initialized. View run at https://modal.com/charlotte-llm/main/apps/ap-xxxxxxxxxx\nâœ“ Created objects.\nâ”œâ”€â”€ ğŸ”¨ Created mount /modal-examples/01_getting_started/get_started_local.py\nâ””â”€â”€ ğŸ”¨ Created function square.\nThis code is running on a local worker!\nthe square is 1764\nStopping app - local entrypoint completed.\nâœ“ App completed. View run at https://modal.com/charlotte-llm/main/apps/ap-xxxxxxxxxx\nVery similar. What happens when we look at the logs:"
  },
  {
    "objectID": "02_building_containers.html#import_sklearn.py",
    "href": "02_building_containers.html#import_sklearn.py",
    "title": "2Â  Building Containers",
    "section": "2.1 import_sklearn.py",
    "text": "2.1 import_sklearn.py\n\n2.1.1 Install scikit-learn in a custom image\nThis builds a custom image which installs the sklearn (scikit-learn) Python package in it. Itâ€™s an example of how you can use packages, even if you donâ€™t have them installed locally.\nFirst, the imports:\nimport time\nimport modal\nNext, weâ€™ll define an app, with a custom image that installs sklearn.\napp = modal.App(\n    \"import-sklearn\",\n    image=modal.Image.debian_slim()\n    .apt_install(\"libgomp1\")\n    .pip_install(\"scikit-learn\"),\n)\nThe app.image.imports() lets us conditionally import in the global scope. This is needed because we might not have sklearn and numpy installed locally, but we know they are installed inside the custom image.\nwith app.image.imports():\n    import numpy as np\n    from sklearn import datasets, linear_model\nNow, letâ€™s define a function that uses one of scikit-learnâ€™s built-in datasets and fits a very simple model (linear regression) to it.\n@app.function()\ndef fit():\n    print(\"Inside run!\")\n    t0 = time.time()\n    diabetes_X, diabetes_y = datasets.load_diabetes(return_X_y=True)\n    diabetes_X = diabetes_X[:, np.newaxis, 2]\n    regr = linear_model.LinearRegression()\n    regr.fit(diabetes_X, diabetes_y)\n    return time.time() - t0\nFinally, weâ€™d trigger the run locally. We also time this. Note that the first time we run this, it will build the image. This might take 1-2 min. When we run this subsequent times, the image is already build, and it will run much much faster.\nif __name__ == \"__main__\":\n    t0 = time.time()\n    with app.run():\n        t = fit.remote()\n        print(\"Function time spent:\", t)\n    print(\"Full time spent:\", time.time() - t0)\nLetâ€™s now run it all:\n$ modal run import_sklearn.py \nâœ“ Initialized. View run at https://modal.com/charlotte-llm/main/apps/ap-xxxxxxxxxx\nBuilding image im-m9EoOtS0dmWsGUat8WCWFc\n\n=&gt; Step 0: FROM base\n\n=&gt; Step 1: RUN apt-get update\nGet:1 http://deb.debian.org/debian bullseye InRelease [116 kB]\nGet:2 http://deb.debian.org/debian-security bullseye-security InRelease [48.4 kB]\nGet:3 http://deb.debian.org/debian bullseye-updates InRelease [44.1 kB]\nGet:4 http://deb.debian.org/debian bullseye/main amd64 Packages [8068 kB]\nGet:5 http://deb.debian.org/debian-security bullseye-security/main amd64 Packages [275 kB]\nGet:6 http://deb.debian.org/debian bullseye-updates/main amd64 Packages.diff/Index [26.3 kB]\nGet:7 http://deb.debian.org/debian bullseye-updates/main amd64 Packages T-2023-12-29-1403.39-F-2023-07-31-2005.11.pdiff [6053 B]\nGet:7 http://deb.debian.org/debian bullseye-updates/main amd64 Packages T-2023-12-29-1403.39-F-2023-07-31-2005.11.pdiff [6053 B]\nGet:8 http://deb.debian.org/debian bullseye-updates/main amd64 Packages [18.8 kB]\nFetched 8602 kB in 4s (2239 kB/s)\nReading package lists...\n\n=&gt; Step 2: RUN apt-get install -y libgomp1\nReading package lists...\nBuilding dependency tree...\nReading state information...\nlibgomp1 is already the newest version (10.2.1-6).\nlibgomp1 set to manually installed.\n0 upgraded, 0 newly installed, 0 to remove and 46 not upgraded.\nCreating image snapshot...\nFinished snapshot; took 1.14s\n\nBuilt image im-m9EoOtS0dmWsGUat8WCWFc in 8.53s\nBuilding image im-Kndkz3TpRhPEMy6UcNR7YR\n\n=&gt; Step 0: FROM base\n\n=&gt; Step 1: RUN python -m pip install scikit-learn \nLooking in indexes: http://pypi-mirror.modal.local:5555/simple\nCollecting scikit-learn\n  Downloading http://pypi-mirror.modal.local:5555/simple/scikit-learn/scikit_learn-1.5.0-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (13.3 MB)\n     â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 13.3/13.3 MB 169.9 MB/s eta 0:00:00\nRequirement already satisfied: numpy&gt;=1.19.5 in /usr/local/lib/python3.10/site-packages (from scikit-learn) (1.25.0)\nCollecting scipy&gt;=1.6.0 (from scikit-learn)\n  Downloading http://pypi-mirror.modal.local:5555/simple/scipy/scipy-1.13.1-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (38.6 MB)\n     â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 38.6/38.6 MB 233.1 MB/s eta 0:00:00\nCollecting joblib&gt;=1.2.0 (from scikit-learn)\n  Downloading http://pypi-mirror.modal.local:5555/simple/joblib/joblib-1.4.2-py3-none-any.whl (301 kB)\n     â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 301.8/301.8 kB 252.9 MB/s eta 0:00:00\nCollecting threadpoolctl&gt;=3.1.0 (from scikit-learn)\n  Downloading http://pypi-mirror.modal.local:5555/simple/threadpoolctl/threadpoolctl-3.5.0-py3-none-any.whl (18 kB)\nInstalling collected packages: threadpoolctl, scipy, joblib, scikit-learn\nSuccessfully installed joblib-1.4.2 scikit-learn-1.5.0 scipy-1.13.1 threadpoolctl-3.5.0\n\n[notice] A new release of pip is available: 23.1.2 -&gt; 24.0\n[notice] To update, run: pip install --upgrade pip\nCreating image snapshot...\nFinished snapshot; took 2.27s\n\nBuilt image im-Kndkz3TpRhPEMy6UcNR7YR in 13.14s\nâœ“ Created objects.\nâ”œâ”€â”€ ğŸ”¨ Created mount /modal-examples/02_building_containers/import_sklearn.py\nâ””â”€â”€ ğŸ”¨ Created function fit.\nInside run!\nStopping app - local entrypoint completed.\nâœ“ App completed. View run at https://modal.com/charlotte-llm/main/apps/ap-xxxxxxxxxx\nSo from the above, it took 8.53s to build the first image, 2.27s to create the snapshot and 13.14s to build the second image. But if we run this again, itâ€™ll be much faster than before as weâ€™ve already."
  },
  {
    "objectID": "02_building_containers.html#import_sklearn_r2.py",
    "href": "02_building_containers.html#import_sklearn_r2.py",
    "title": "2Â  Building Containers",
    "section": "2.2 import_sklearn_r2.py",
    "text": "2.2 import_sklearn_r2.py\nJust for fun, letâ€™s modify this script to now output the R^2 value on the test data.\n\n\nimport_sklearn_r2.py\n\nimport time\nimport modal\n\napp = modal.App(\n    \"import-sklearn\",\n    image=modal.Image.debian_slim()\n    .apt_install(\"libgomp1\")\n    .pip_install(\"scikit-learn\"),\n)\n\nwith app.image.imports():\n    import numpy as np\n    from sklearn import datasets, linear_model\n    from sklearn.model_selection import train_test_split\n    from sklearn.metrics import r2_score\n\n@app.function()\ndef fit():\n    print(\"Inside run!\")\n    X, y = datasets.load_diabetes(return_X_y=True)\n    X = X[:, np.newaxis, 2]\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42)\n    regr = linear_model.LinearRegression()\n    regr.fit(X_train, y_train)\n    predict = regr.predict(X_test)\n    \n    return r2_score(predict, y_test)\n\n\nif __name__ == \"__main__\":\n    t0 = time.time()\n    with app.run():\n        t = fit.remote()\n        print(\"R Squared is:\", t)\n    print(\"Full time spent:\", time.time() - t0)\n\nRunning this, we get:\n$ modal run import_sklearn_r2.py\nâœ“ Initialized. View run at https://modal.com/charlotte-llm/main/apps/ap-xxxxxxxxx\nâœ“ Created objects.\nâ”œâ”€â”€ ğŸ”¨ Created mount /modal-examples/02_building_containers/import_sklearn_r2.py\nâ””â”€â”€ ğŸ”¨ Created function fit.\nInside run!\nStopping app - local entrypoint completed.\nâœ“ App completed. View run at https://modal.com/charlotte-llm/main/apps/ap-xxxxxxxxxx\nThis result somewhat surprised me.\nFirst, I didnâ€™t see the output R^2. I was expecting this perhaps the first time running, but didnâ€™t see it.\nSecond, after running, unlike the previous example that shut down immediately, this container was running ephemerally:\n\nTBD - understand whatâ€™s going on."
  },
  {
    "objectID": "02_building_containers.html#install_cuda.py",
    "href": "02_building_containers.html#install_cuda.py",
    "title": "2Â  Building Containers",
    "section": "2.3 install_cuda.py",
    "text": "2.3 install_cuda.py\nTBD"
  },
  {
    "objectID": "02_building_containers.html#screenshot.py",
    "href": "02_building_containers.html#screenshot.py",
    "title": "2Â  Building Containers",
    "section": "2.4 screenshot.py",
    "text": "2.4 screenshot.py\nTBD"
  }
]